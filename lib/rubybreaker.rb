#--
# This library dynamically profiles and resolves the type information
# observed at runtime and generates type annotation at the end.  It can be
# run as either a stand-alone script or as a Ruby library. 

require_relative "rubybreaker/runtime"
require_relative "rubybreaker/test"

# RubyBreaker is a dynamic instrumentation and monitoring tool that
# documents type information automatically.
module RubyBreaker

  # This constant contains the copyright information.
  COPYRIGHT = "Copyright (c) 2012 Jong-hoon (David) An. All Rights Reserved."

  # Options for RubyBreaker
  OPTIONS = {
    :debug => false,               # in debug mode?
    :verbose => true,              # in verbose mode?
    :mode => :lib,                 # bin or lib?
    :io_file => nil,               # generate input/output other than default?
    :append => true,               # append to the input file (if there is)?
    :stdout => true,               # also display on the screen?
    :rubylib => true,              # include core ruby library documentation?
  }

  # This array lists modules/classes that are actually instrumented with a
  # monitor.
  INSTALLED = []
  
  # This array lists monitored modules/classes that are outputed.
  DOCUMENTED = []

  # Extension used by RubyBreaker for output/input
  EXTENSION = "rubybreaker"

  # This module has a set of entry points to the program and misc. methods
  # for running RubyBreaker.
  module Main

    include TypeDefs
    include Runtime

    public

    # This method is the trigger point to install a monitor in each
    # module/class.
    def self.setup()

      BREAKABLE.each do |m|
        # Avoid already installed module or now Broken module. Remember,
        # once a module is a declared to be Broken, it wins. Broken modules
        # cannot be Breakable!
        unless INSTALLED.include?(m) || BROKEN.include?(m)
          MonitorInstaller.install_module_monitor(m,true)
          INSTALLED << m
        end
      end

      # At the end, we generate an output of the type information.
      at_exit do 
        self.output
      end

    end

    # Reads the input file if specified or exists
    def self.input()
      return unless OPTIONS[:io_file] && File.exist?(OPTIONS[:io_file])
      eval "load \"#{OPTIONS[:io_file]}\"", TOPLEVEL_BINDING
    end

    # This method will generate the output 
    def self.output()

      io_exist = OPTIONS[:io_file] && File.exist?(OPTIONS[:io_file])

      str = ""
      pp = PrettyPrint.new(str)

      # Document each module that was monitored
      INSTALLED.each do |mod|

        # Skip it if we already have seen it
        next if DOCUMENTED.include?(mod)
        DOCUMENTED << mod 

        pp.text("class #{mod.to_s}")
        pp.nest(2) do 
          pp.breakable("")
          pp.text("include RubyBreaker::Broken")
          meth_type_map = Inspector.inspect_all(mod)
          meth_type_map.each { |meth_name, meth_type|
            case meth_type
            when MethodType
              pp.breakable()
              pp.text("typesig(\"")
              TypeUnparser.unparse_pp(pp,meth_type)
              pp.text("\")")
            when MethodListType
              meth_type.types.each { |real_meth_type|
                pp.breakable()
                pp.text("typesig(\"")
                TypeUnparser.unparse_pp(pp,real_meth_type)
                pp.text("\")")
              }
            else
              # Can't happen
            end
          }
        end
        pp.breakable() 
        pp.text("end")
        pp.breakable()
      end
      pp.flush

      # First, display the result on the stdout if set
      puts str if OPTIONS[:stdout]

      # If this was a library mode run, exit now. 
      return if OPTIONS[:mode] == :lib

      # Append the result to the input file (or create a new file)
      open(OPTIONS[:io_file],"a") do |f|
        unless io_exist 
          f.puts "# This file is auto-generated by RubyBreaker"
          # f.puts "require \"rubybreaker\""
        end
        f.puts str
      end

    end

    # This method will run the input file
    def self.run()

      # First, take care of the program file.

      argv0 = ARGV[0]
      prog_file = argv0
      prog_file = File.expand_path(prog_file)

      # It is ok to omit .rb extension. So try to see if prog_file.rb exists
      if !File.exist?(prog_file) && !File.extname(prog_file) == ".rb" 
        prog_file = "#{prog_file}.rb"
      end 

      if !File.exist?(prog_file)
        puts "ERROR: '#{argv0}' is an invalid file."
        exit(1)
      end

      # Then, input/output file if specified
      if !OPTIONS[:io_file] || OPTIONS[:io_file].empty?
        OPTIONS[:io_file] = "#{File.basename(argv0, ".rb")}.#{EXTENSION}"
      end
      OPTIONS[:io_file] = File.absolute_path(OPTIONS[:io_file])

      if OPTIONS[:rubylib]
        # Load the core library type documentation
        eval("require_relative \"#{File.dirname(__FILE__)}/rubybreaker/rubylib\"", TOPLEVEL_BINDING)
      end

      # Read the input file first (as it might contain type documentation
      # already)
      Main.input()

      # Finally, require the program file! Let it run! Wheeee!
      eval "require '#{prog_file}'", TOPLEVEL_BINDING

    end

  end

  # Just redirecting
  def self.monitor()
    Main.setup()
  end

end

