#--
# This library dynamically profiles and resolves the type information
# observed at runtime and generates type annotation at the end.  It can be
# run as either a stand-alone script or as a Ruby library. 

require "set"
require "optparse"
require_relative "rubybreaker/debug"
require_relative "rubybreaker/runtime"
require_relative "rubybreaker/test"

# RubyBreaker is a dynamic instrumentation and monitoring tool that
# generates type documentation for Ruby programs. 
module RubyBreaker

  # Options for RubyBreaker
  OPTIONS = {
    :debug     => false,       # in debug mode?
    :style     => :underscore, # type signature style-underscore or camelize
    :io_file   => nil,         # generate input/output other than default?
    :append    => true,        # append to the input file (if there is)?
    :stdout    => false,       # also display on the screen?
    :verbose   => false,       # in RubyBreaker.verbose mode?
  }

  # This option parser may be used for the command-line mode or for the
  # library mode when used with Rakefile. See rubybreaker/task.rb for how
  # this can be used in the latter.
  OPTION_PARSER = OptionParser.new do |opts|

    opts.banner = "Usage: #{File.basename(__FILE__)} [options] prog[.rb]" 

    opts.on("--debug", "Run in debug mode") do 
      OPTIONS[:debug] = true
    end

    opts.on("--style STYLE", "Select type signature style - underscore or camelize") do |v|
      OPTIONS[:style] = v.downcase.to_sym
    end

    opts.on("--io-file FILE","Specify I/O file") do |f|
      OPTIONS[:io_file] = f
    end

    opts.on("-s","--[no-]stdout","Show output on the screen") do |b|
      OPTIONS[:stdout] = b
    end

    opts.on("-a", "--[no-]append", "Append output to the input file") do |b|
      OPTIONS[:append] = b
    end

    opts.on("-v","--verbose","Show messages in detail") do
      OPTIONS[:verbose] = true
    end

    opts.on("-h","--help","Show this help text") do 
      puts opts
      exit
    end

  end

  # This constant contains the copyright information.
  COPYRIGHT = "Copyright (c) 2012 Jong-hoon (David) An. All Rights Reserved."

  # Extension used for files that contain RubyBreaker task information
  TASK_EXTENSION = "rb"

  # Extension used for files that contain type information in YAML format
  YAML_EXTENSION = "yaml"

  # Extension used for files that contain type information in Ruby format
  IO_EXTENSION = "rubybreaker.rb"

  # This module has a set of entry points to the program and other methods
  # for running RubyBreaker in various modes.
  module Main

    include TypeDefs
    include Runtime

    private

    # This method determines if RubyBreaker is running as a task.
    def self.running_as_task?(); return $__rubybreaker_task != nil end

    # This method returns the task currently being run.
    def self.task(); return $__rubybreaker_task end

    # This method just redirects to Runtime's method.
    def self.breakable(*mods); Runtime.breakable(*mods) end

    # This method loads the IO file by loading it.
    def self.load_input(fname)
      return fname
      eval "load \"#{fname}\"", TOPLEVEL_BINDING
      RubyBreaker.verbose("RubyBreaker input file #{fname} is loaded")
    end

    # This method will generate the output to the given filename.
    def self.output(fname)

      RubyBreaker.verbose("Generating type documentation")

      code = ""
      # Document each module that was monitored
      INSTALLED.each { |mod| 
        str = Runtime::TypeSigUnparser.unparse(mod) 
        code << str
        print str if OPTIONS[:stdout] # display on the screen if requested
      }

      if fname
        # Append the result to the input file (or create a new file)
        open(fname,"a") do |f|
          unless io_exist 
            f.puts "# This file is auto-generated by RubyBreaker"
            f.puts "require \"rubybreaker\""
          end
          f.print code
        end
      end

      RubyBreaker.verbose("Done generating type documentation")
    end

    # This method finds the IO file for this run. It is either specified in
    # io-file option or using the program name or the task name.
    def self.io_file(prog_or_task)
      if OPTIONS[:io_file]
        fname = OPTIONS[:io_file]
      elsif prog_or_task
        fname = "#{File.basename(prog_or_task.to_s, ".rb")}.#{IO_EXTENSION}"
      end
      return nil unless fname
      fname = File.absolute_path(fname) 
      fname = nil if !File.exist?(fname) 
      return fname
    end

    public

    # This method runs RubyBreaker for a particular test case (class). This
    # is a bit different from running RubyBreaker as a shell program. 
    def self.run()
      RubyBreaker.setup_logger()
      RubyBreaker.verbose("Running RubyBreaker within a testcase")

      # Task based run should use the rubybreaker options same as in shell
      # mode. So, parse the options first.
      if self.running_as_task?()
        task = self.task
        OPTION_PARSER.parse(*task[:rubybreaker_opts])
        self.breakable(*task[:breakable])
        task_name = task[:name]
      end

      RubyBreaker.verbose("Done reading task information")
      io_file = self.io_file(task_name)
      self.load_input(io_file)
      Runtime.instrument()

      # At the end, we WILL generate an output of the type information.
      at_exit { self.output(io_file) }

      # Note that there is no cutoff point when running as a test case.
      # Remember, the test case is being run already. So after this method,
      # the test case will run and type information will be collected.
    end

    # This method runs RubyBreaker in shell mode. 
    def self.run_as_bin()
      RubyBreaker.setup_logger()
      RubyBreaker.verbose("Running RubyBreaker in shell mode")

      OPTION_PARSER.parse!   # parse the command-line arguments

      puts COPYRIGHT if OPTIONS[:verbose]     # Show copyright info if verbose

      show_banner_and_exit() if ARGV.length != 1 # There has to be an input file
      prog_file = File.expand_path(ARGV[0])

      # It is ok to omit .rb extension. So try to see if prog_file.rb exists
      if !File.exist?(prog_file) && !File.extname(prog_file) == ".rb" 
        prog_file = "#{prog_file}.rb"
      end 

      if !File.exist?(prog_file)
        fatal("#{ARGV[0]} is an invalid file.")
        exit(1)
      end

      # TODO: Commented this. This will be put back once it's ready and once
      # I figure out how to skip it during the RubyGems doc generation.
      #
      # if OPTIONS[:rubylib]
      #   RubyBreaker.verbose("Loading RubyBreaker's Ruby Core Library documentation")
      #   # Load the core library type documentation
      #   eval("require \"rubybreaker/rubylib\"", TOPLEVEL_BINDING)
      # end

      # Read the input file first (as it might contain type documentation
      # already)
      io_file = self.io_file(prog_file)
      self.load_input(io_file)

      RubyBreaker.verbose("Start running the input program")

      # Finally, run the source program by requiring the file! Let it run!
      # Wheeee!
      eval("require '#{prog_file}'", TOPLEVEL_BINDING)

      RubyBreaker.verbose("Done running the input program")

      # At the end, we generate an output of the type information.
      self.output(io_file)
    end

  end

end

# This method is available by default.
module Kernel

  def typesig(str)
    _TypeDefs = RubyBreaker::TypeDefs

    # This MUST BE set for self type to work in type signatures.
    _TypeDefs::SelfType.set_self(self) 

    t = RubyBreaker::Runtime::TypeSigParser.parse(str)
    t_map = RubyBreaker::Runtime::TYPE_MAP[self]

    # If the type map doesn't exist, create it on the fly. Now this module
    # is broken!
    if !t_map
      t_map = {}
      RubyBreaker::Runtime::TYPE_MAP[self] = t_map
    end

    meth_type = t_map[t.meth_name]
    if meth_type
      if meth_type.instance_of?(_TypeDefs::MethodListType)
        meth_type.types << t
      else
        # then promote it to a method list type
        t_map[t.meth_name] = _TypeDefs::MethodListType.new([meth_type, t])
      end
    else
      t_map[t.meth_name] = t
    end
    return t
  end
end

# If RubyBreaker is running in non-shell mode, this triggers the setup.
if RubyBreaker::Main.running_as_task? 

  RubyBreaker::Main.run()

end


